import 'dart:io';
import 'package:path/path.dart' as path;

/// A utility class for managing file and directory paths used in the distribution process.
///
/// The [Files] class provides static references to commonly used files and directories,
/// such as Android and iOS distribution directories, changelogs, and metadata paths.
/// This class cannot be instantiated.
class Files {
  /// Private constructor to prevent instantiation.
  ///
  /// The [Files] class is intended to be used only with its static members.
  Files._();

  /// The file containing Android changelogs.
  static final File androidChangeLogs =
      File(path.join("distribution", "android", "output", "changelogs.log"));

  /// The Fastlane JSON configuration file.
  static final File fastlaneJson =
      File(path.join("distribution", "fastlane.json"));

  /// The root directory for Android distribution files.
  static final Directory androidDistributionDir =
      Directory(path.join("distribution", "android"));

  /// The directory containing Android app bundles generated by the build process.
  static final Directory androidOutputAppbundles =
      Directory(path.join("build", "app", "outputs", "bundle"));

  /// The directory containing Android APKs generated by the build process.
  static final Directory androidOutputApks =
      Directory(path.join("build", "app", "outputs", "flutter-apk"));

  /// The output directory for Android distribution files.
  static final Directory androidDistributionOutputDir =
      Directory(path.join(androidDistributionDir.path, "output"));

  /// The metadata directory for Android distribution files.
  static final Directory androidDistributionMetadataDir =
      Directory(path.join(androidDistributionDir.path, "metadata"));

  /// The root directory for custom distribution files.
  static final Directory customDir =
      Directory(path.join("distribution", "custom"));

  /// The metadata directory for custom distribution files.
  static final Directory customOutputMetadataDir =
      Directory(path.join(customDir.path, "metadata"));

  /// The output directory for custom distribution files.
  static final Directory customOutputDir =
      Directory(path.join(customDir.path, "output"));

  /// The root directory for iOS distribution files.
  static final Directory iosDistributionDir =
      Directory(path.join("distribution", "ios"));

  /// The directory containing iOS IPA files generated by the build process.
  static final Directory iosOutputIPA =
      Directory(path.join("build", "ios", "ipa"));

  /// The output directory for iOS distribution files.
  static final Directory iosDistributionOutputDir =
      Directory(path.join(iosDistributionDir.path, "output"));

  /// The metadata directory for iOS distribution files.
  static final Directory iosDistributionMetadataDir =
      Directory(path.join(iosDistributionDir.path, "metadata"));

  /// Copies files from [source] to [target] directory.
  ///
  /// Optionally filters files by [fileType] and [mode].
  /// Returns the path of the first copied file, or throws if no files are found.
  static Future<String?> copyFiles(String source, String target,
      {List<String> fileType = const [], String mode = "release"}) async {
    final sourceDir = Directory(source);
    final files = await sourceDir.list().toList();
    final targetDir = Directory(target);
    if (!targetDir.existsSync()) {
      await targetDir.create(recursive: true);
    }
    final output = <String>[];
    if (files.isEmpty) {
      throw Exception("No files found in ${sourceDir.path}");
    }
    for (var item in files) {
      if (item is Directory) {
        final copiedFiles =
            await copyFiles(item.path, target, fileType: fileType);
        if (copiedFiles != null) output.add(copiedFiles);
      } else {
        if (fileType.isEmpty) {
          if (item is File) {
            final fileName = path.basename(item.path);
            final targetPath = path.join(target, fileName);
            output.add(targetPath);
            if (File(targetPath).existsSync()) {
              await File(targetPath).delete();
            }
            await item.copy(targetPath);
          }
        } else if (item is File &&
            fileType.contains(path.extension(item.path).substring(1))) {
          final fileName = path.basename(item.path);
          final targetPath = path.join(target, fileName);
          output.add(targetPath);
          if (File(targetPath).existsSync()) {
            await File(targetPath).delete();
          }
          await item.copy(targetPath);
        }
      }
    }
    if (output.isEmpty) {
      throw Exception(
          "Does not contain any files with the specified type: $fileType");
    }
    return output.first;
  }
}
